<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
</head>
<body>

<script src="js/threejs/lib/Three.js"></script>
<script src="js/threejs/lib/Detector.js"></script>
<script src="js/threejs/lib/KeyboardState.js"></script>
<script src="js/threejs/lib/THREEx.FullScreen.js"></script>
<script src="js/threejs/lib/THREEx.WindowResize.js"></script>

<!--
Scene navigation (first-person style):

W/S/A/D/R/F: move forwards/backwards/left/right/up/down
>Q/E: turn left/right; hold both to face positive X direction
T/G: look up/down; hold both to center look at horizon
O/P: reset position and view to origin/birds-eye
>M: toggle browser full screen mode


Z/X/C: set brush mode to add/delete/(re)color
0 through 9: set brush color
V or Mouse Click: perform brush action
B: delete most recently added brick
-->

<div id="ThreeJSExperiment"></div>

<script>

// standard global variables
var ExperimentContainer, ExperimentScene, ExperimentCamera, ExperimentRenderer, ExperimentControls;
var keyboard = new KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var mesh;
var person;

function viewSet(n) {
  // on ground near origin
	if (n == 1) {
		person.position.set(-10, 3, 16);
		person.rotation.set(0, -Math.PI / 2.0, 0);
		ExperimentCamera.rotation.set(-Math.PI / 16.0, 0, 0);
	}

  // birds-eye view
	if (n == 2) {
		person.position.set(16, 42, 16);
		person.rotation.set(0, -Math.PI / 2.0, 0);
		ExperimentCamera.rotation.set(-1.48, 0, 0);
	}
}

initExperiment();
animateExperiment();

// FUNCTIONS
function initExperiment() {
	// SCENE
	ExperimentScene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 55, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 2000;
	ExperimentCamera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	// First Person Camera Controls
	person = new THREE.Object3D();
	person.add(ExperimentCamera);
	ExperimentCamera.position.set(0, 1.0, 4.0); // first-person view
	viewSet(2);
	ExperimentScene.add(person);

	// RENDERER
	if ( Detector.webgl ) {
		ExperimentRenderer = new THREE.WebGLRenderer( {antialias:true} );
  } else {
		ExperimentRenderer = new THREE.CanvasRenderer();
  }

  ExperimentRenderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	ExperimentContainer = document.getElementById( 'ThreeJSExperiment' );
	ExperimentContainer.appendChild( ExperimentRenderer.domElement );

  // EVENTS
	THREEx.WindowResize(ExperimentRenderer, ExperimentCamera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	// LIGHT
  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 50, 0 );
	ExperimentScene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight( 0xdfebff, 1 );
  dirLight.position.set( 50, 200, 100 );
  dirLight.position.multiplyScalar( 1.3 );

  ExperimentScene.add(dirLight);

  // SKYBOX - Background
	var skyBoxGeometry = new THREE.CubeGeometry( 1000, 1000, 1000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	ExperimentScene.add(skyBox);

	////////////
	// CUSTOM //
	////////////


  /*  Will create an image on the plane
	var squareT = new THREE.ImageUtils.loadTexture("images/Chrome.png");
	squareT.wrapS = squareT.wrapT = THREE.RepeatWrapping;
	squareT.repeat.set(1,1);
  */

  //Creates dimesions for planting the stimulus
	this.BoardGeo = new THREE.PlaneGeometry(40,40);

  // for creating image on plane
  //this.planeMat = new THREE.MeshBasicMaterial({map:squareT, color:0xbbbbbb});

	this.BoardMat = new THREE.MeshPhongMaterial({ color: 0x4f0059,  specular: 0x050505, shininess: 30 });

  var ExperiBoard = new THREE.Mesh(BoardGeo, BoardMat);
	ExperiBoard.rotation.x = -Math.PI / 2;
	ExperiBoard.position.set(16,-1,16);
	ExperiBoard.base = true;
	ExperimentScene.add(ExperiBoard);

	this.stimuliGeo = new THREE.CylinderGeometry(1,1,3,100);

	this.offset = [
		new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
		new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
		new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1) ];

//this will generate the stimulus
	this.colors = [ new THREE.Color(0x66FFFF), new THREE.Color(0xff0000), new THREE.Color(0xff8800), new THREE.Color(0xffff00), new THREE.Color(0x00cc00),
	                new THREE.Color(0x0000ff), new THREE.Color(0x8800ff), new THREE.Color(0x804000), new THREE.Color(0x222222), new THREE.Color(0xFF66FF) ];

  this.label = ["Deon", "Jeffery", "Rico", "Flynt", "Mitchell"];

  this.materials = { "solid":[], "add":[], "delete":[] };


  for (var i = 0; i < colors.length; i++) {
		materials["solid"][i]   = new THREE.MeshLambertMaterial({ color: colors[i] });
		materials["add"][i]     = new THREE.MeshLambertMaterial({ color: colors[i], transparent: true, opacity:0.50 });
		materials["delete"][i]  = new THREE.MeshLambertMaterial({ color: colors[i], transparent: true, opacity:0.75 });
	}

	this.brush = new THREE.Mesh( stimuliGeo.clone(), materials["add"][1] );
	brush.ignore = true;    // ignored by raycaster
	brush.visible = false;
	brush.mode = "add";
	brush.colorIndex = 1;
	ExperimentScene.add( brush );
	this.stimuliNames = [];

	this.projector = new THREE.Projector();
	this.mouse2D = new THREE.Vector3( 0, 0, 0.5 );

	// when the mouse moves, call the given function
	document.addEventListener( 'mousemove', mouseMove,  false );
	document.addEventListener( 'mousedown', mouseClick, false );
}

function mouseMove( event ) {
	// update the mouse variable
	mouse2D.x =   ( event.clientX / window.innerWidth  ) * 2 - 1;
	mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
}

function mouseClick( event ) {
	brushAction();
}

  var i = 0;
function brushAction() {
  var spritey;
	if (brush.mode == "add") {
		var stimuli = new THREE.Mesh( stimuliGeo );
    stimuli.material = materials["solid"][ brush.colorIndex ];
		stimuli.position = brush.position.clone();
		stimuli.name = brush.addName;
		stimuli.colorIndex = brush.colorIndex;
		ExperimentScene.add( stimuli );
		stimuliNames.push( stimuli.name );

    //creates the label for the stimulus
    spritey = makeTextSprite( label[i], { fontsize: 32, backgroundColor: {r:0, g:0, b:0, a:0} } );
    spritey.position = brush.position.clone();
    spritey.position.y = 2;
    ExperimentScene.add( spritey );
    i++;

	}

	if (brush.mode == "delete") {
		var stimuli = ExperimentScene.getObjectByName( brush.targetName );
		ExperimentScene.remove( stimuli );
		var index = stimuliNames.indexOf( brush.targetName );
		if ( index != -1 ) stimuliNames.splice( index, 1 );
	}
}

function animateExperiment() {
  requestAnimationFrame( animateExperiment );
	render();
	update();
}

function update() {
	var delta = clock.getDelta();
	var moveDistance = 10 * delta; 			// 5 units per second
	var rotateAngle = Math.PI / 4 * delta;	// pi/4 radians (45 degrees) per second

	keyboard.update();

	// move forwards/backwards
	if (keyboard.pressed("W"))
		person.translateZ( -moveDistance );
	if (keyboard.pressed("S"))
		person.translateZ(  moveDistance );
	// move left/right (strafe)
	if ( keyboard.pressed("A") )
		person.translateX( -moveDistance );
	if ( keyboard.pressed("D") )
		person.translateX(  moveDistance );
	// move up/down (fly)
	if ( keyboard.pressed("R") )
		person.translateY(  moveDistance );
	if ( keyboard.pressed("F") )
		person.translateY( -moveDistance );
	// turn left/right
	if (keyboard.pressed("Q"))
		person.rotateY(  rotateAngle );
	if (keyboard.pressed("E"))
		person.rotateY( -rotateAngle );
	// look up/down
	if ( keyboard.pressed("T") )
		ExperimentCamera.rotateX(  rotateAngle );
	if ( keyboard.pressed("G") )
		ExperimentCamera.rotateX( -rotateAngle );
	// limit ExperimentCamera to +/- 45 degrees (0.7071 radians) or +/- 60 degrees (1.04 radians) or 85 (1.48)
	ExperimentCamera.rotation.x = THREE.Math.clamp( ExperimentCamera.rotation.x, -1.48, 1.48 );
	// pressing both buttons moves look angle to original position
	var factor = (Math.abs(person.rotation.x) < 0.0001) ? -1 : 1;
	if ( keyboard.pressed("Q") && keyboard.pressed("E") )
		person.rotateY( -6 * (-Math.PI / 2.0 - person.rotation.y) * rotateAngle * factor );
	if ( keyboard.pressed("T") && keyboard.pressed("G") )
		ExperimentCamera.rotateX( -6 * ExperimentCamera.rotation.x * rotateAngle );
	// set view to Origin
	if (keyboard.down("O"))
		viewSet(1);
	// set view to bird's-eye-view (Pigeon's-eye-view?)
	if (keyboard.down("P"))
		viewSet(2);

	// when digit is pressed, change brush color data
	for (var i = 0; i < 10; i++)
	if ( keyboard.down( i.toString() ) )
		brush.colorIndex = i;

	brush.material = materials["add"][ brush.colorIndex ];
	// brush modes
	if ( keyboard.down("Z") )
		brush.mode = "add";
	if ( keyboard.down("X") )
		brush.mode = "delete";


	///////////////////////////////////////////////////////////////////////////

	var raycaster = projector.pickingRay( mouse2D.clone(), ExperimentCamera );
	var intersectionList = [];
	intersectionList = raycaster.intersectObjects( ExperimentScene.children );
	var result = null;
	for ( var i = 0; i < intersectionList.length; i++ ) {
		if ( (result == null) && (intersectionList[i].object instanceof THREE.Mesh) && !(intersectionList[i].object.ignore) )
			result = intersectionList[i];
	}

	// brush will only be visible only in "add" mode, when mouse hovers over plane/stimuli
	brush.visible = false;
	// restore appearance of potential delete/(re)color target stimuli
	var targetCube = ExperimentScene.getObjectByName( brush.targetName );
	if ( targetCube )
		targetCube.material = materials["solid"][ targetCube.colorIndex ];
	brush.targetName = null;

	if ( result ) {
     //place stimuli on ExperiBoard
		if ( (brush.mode == "add") && result.object.base ) {
			brush.visible = true;
			var intPosition = new THREE.Vector3( Math.floor(result.point.x), 0, Math.floor(result.point.z) );
			brush.position = intPosition.clone().add( new THREE.Vector3(0.5, 0.5, 0.5) );
			brush.addName = "X" + intPosition.x + "Y" + intPosition.y + "Z" + intPosition.z;
		}

    // delete stimuli
		if ( (brush.mode == "delete") && !result.object.base ) {
			brush.visible = false;
			var intPosition = new THREE.Vector3( Math.floor(result.object.position.x),
				Math.floor(result.object.position.y), Math.floor(result.object.position.z) );
			brush.targetName = "X" + intPosition.x + "Y" + intPosition.y + "Z" + intPosition.z;
			var targetCube = ExperimentScene.getObjectByName( brush.targetName );
			targetCube.material = materials["delete"][ targetCube.colorIndex ];
		}
	}
}

function makeTextSprite( message, parameters )
{
  if ( parameters === undefined ) parameters = {};

  var fontface = parameters.hasOwnProperty("fontface") ?
  parameters["fontface"] : "Arial";

  var fontsize = parameters.hasOwnProperty("fontsize") ?
  parameters["fontsize"] : 18;

  var borderThickness = parameters.hasOwnProperty("borderThickness") ?
  parameters["borderThickness"] : 4;

  var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
  parameters["backgroundColor"] : { r:255, g:255, b:255, a:0 };

  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  context.font = "Bold " + fontsize + "px " + fontface;

  // get size data (height depends only on font size)
  var metrics = context.measureText( message );
  var textWidth = metrics.width;

  // background color
  context.fill();
  context.stroke();

  // text color
  context.fillStyle = "rgba(255, 255, 255, 1.0)";

  context.fillText( message, borderThickness, fontsize + borderThickness);

  // canvas contents will be used for a texture
  var texture = new THREE.Texture(canvas)
  texture.needsUpdate = true;

  var spriteMaterial = new THREE.SpriteMaterial(
    { map: texture, useScreenCoordinates: false } );
    var sprite = new THREE.Sprite( spriteMaterial );
    sprite.scale.set(8,4,0);
    return sprite;
  }

function render() {
	ExperimentRenderer.render( ExperimentScene, ExperimentCamera );
}

</script>

</body>
</html>
